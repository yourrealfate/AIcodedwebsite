<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Retro Center with Custom GUI, Search, and Games</title>
  <style>
    /* Global and Reset Styles */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #101010;
      font-family: Arial, sans-serif;
      color: #fff;
    }
    /* Navigation Bar */
    #navBar {
      position: fixed;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      padding: 5px 10px;
      z-index: 10;
    }
    #navBar button {
      margin-right: 10px;
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #1c8adb;
      color: #fff;
    }
    #navBar button:hover {
      background: #166bb2;
    }
    /* Main Container for Search */
    #mainContainer {
      position: relative;
      z-index: 2;
      text-align: center;
      padding-top: 80px; /* leave room for navbar */
    }
    .search-box {
      background: rgba(0, 0, 0, 0.65);
      padding: 20px;
      border-radius: 8px;
      display: inline-block;
      margin-bottom: 20px;
    }
    .search-box input[type="text"] {
      padding: 10px;
      width: 300px;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      margin-right: 10px;
    }
    .search-box button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background: #1c8adb;
      color: #fff;
      cursor: pointer;
    }
    .search-box button:hover {
      background: #166bb2;
    }
    .search-box select {
      padding: 8px;
      font-size: 16px;
      margin-bottom: 10px;
      border-radius: 4px;
      border: none;
    }
    /* Floating Shapes */
    .shape {
      position: absolute;
      animation: float 8s ease-in-out infinite;
    }
    @keyframes float {
      0% { transform: translateY(0); opacity: 0.7; }
      50% { transform: translateY(-30px); opacity: 0.3; }
      100% { transform: translateY(0); opacity: 0.7; }
    }
    /* Settings Panel */
    #settingsPanel {
      position: fixed;
      top: 50px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 250px;
      font-size: 14px;
      z-index: 10;
      display: none;
    }
    #settingsPanel label {
      display: block;
      margin-top: 10px;
    }
    #settingsPanel input[type="color"],
    #settingsPanel input[type="range"],
    #settingsPanel select {
      width: 100%;
      margin-top: 5px;
    }
    /* Games Menu */
    #gamesMenu {
      position: fixed;
      top: 50px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 200px;
      font-size: 14px;
      z-index: 10;
      display: none;
    }
    #gamesMenu button {
      display: block;
      width: 100%;
      margin-bottom: 10px;
    }
    /* Game Containers */
    .gameContainer {
      display: none;
      position: absolute;
      top: 80px;
      left: 0;
      width: 100%;
      height: calc(100% - 80px);
      background: #000;
      z-index: 5;
      text-align: center;
    }
    .gameContainer canvas {
      background: #111;
      margin-top: 20px;
    }
    .gameContainer button {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <div id="navBar">
    <!-- "NettleWeb" button now opens the embedded SVG in a new tab -->
    <button id="nettleBtn" onclick="openNettleWeb()">NettleWeb</button>
    <button id="toggleSettingsBtn" onclick="toggleSettings()">Settings</button>
    <button id="gamesBtn" onclick="toggleGamesMenu()">Games</button>
  </div>
  
  <!-- Settings Panel for Customization -->
  <div id="settingsPanel">
    <strong>Customize Look</strong>
    <label for="bgColorPicker">Background Color:</label>
    <input type="color" id="bgColorPicker" value="#101010">
    
    <label for="bgBrightnessSlider">Background Brightness:</label>
    <input type="range" id="bgBrightnessSlider" min="0.5" max="1.5" step="0.01" value="1">
    
    <label for="textboxColorPicker">Textbox Color:</label>
    <input type="color" id="textboxColorPicker" value="#ffffff">
    
    <label for="shapeColorPicker">Floating Shape Color:</label>
    <input type="color" id="shapeColorPicker" value="#ffffff">
    
    <label for="shapeTypeSelect">Shape Type:</label>
    <select id="shapeTypeSelect">
      <option value="circle" selected>Circle</option>
      <option value="square">Square</option>
    </select>
    
    <label for="shapeCountSlider">Number of Shapes:</label>
    <input type="range" id="shapeCountSlider" min="10" max="50" step="1" value="20">
  </div>
  
  <!-- Games Menu -->
  <div id="gamesMenu">
    <strong>Games</strong>
    <button onclick="startFlappy()">Flappy Bird</button>
    <button onclick="startSnake()">Snake</button>
    <button onclick="startPacman()">Pacman</button>
    <button onclick="toggleGamesMenu()">Close</button>
  </div>
  
  <!-- Main Search Container -->
  <div id="mainContainer">
    <h1>About Blank Embedder</h1>
    <div class="search-box">
      <label for="proxySelect">Choose Proxy:</label>
      <select id="proxySelect">
        <option value="">None</option>
        <option value="https://holyunblocker.org/?go=">Holy Unblocker</option>
        <option value="https://titanium-proxy.example.com/?go=">Titanium Proxy</option>
      </select>
      <br><br>
      <input type="text" id="searchInput" placeholder="Enter URL or search query..." required>
      <button onclick="openInAboutBlank()">Go</button>
    </div>
  </div>
  
  <!-- Game Containers -->
  <div class="gameContainer" id="flappyGame">
    <h2>Flappy Bird</h2>
    <canvas id="flappyCanvas" width="400" height="600"></canvas>
    <br>
    <button onclick="exitGame()">Back</button>
  </div>
  <div class="gameContainer" id="snakeGame">
    <h2>Snake</h2>
    <canvas id="snakeCanvas" width="400" height="400"></canvas>
    <br>
    <button onclick="exitGame()">Back</button>
  </div>
  <div class="gameContainer" id="pacmanGame">
    <h2>Pacman</h2>
    <canvas id="pacmanCanvas" width="400" height="400"></canvas>
    <br>
    <button onclick="exitGame()">Back</button>
  </div>
  
  <script>
    // Global variables for game timers and current active game.
    let gameInterval, snakeInterval, pacmanInterval;
    let currentGame = "";
    
    // --- Utility Functions ---
    function openNettleWeb() {
      // Open the provided SVG (encoded as a data URL) in a new tab.
      window.open("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiID8+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTI4MCIgaGVpZ2h0PSI3MjAiIHZpZXdCb3g9IjAgMCAxMjgwIDcyMCI+Cgk8dGl0bGU+R29vZ2xlPC90aXRsZT4KCTxmb3JlaWduT2JqZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMjgwIiBoZWlnaHQ9IjcyMCI+CgkJPGVtYmVkIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzcmM9Imh0dHBzOi8vbmV0dGxld2ViLmNvbS8iIHR5cGU9InRleHQvcGxhaW4iIHdpZHRoPSIxMjYwIiBoZWlnaHQ9IjcwMCIgLz4KCTwvZm9yZWduT2JqZWN0Pgo8L3N2Zz4=", "_blank");
    }
    function toggleSettings() {
      const panel = document.getElementById("settingsPanel");
      panel.style.display = (panel.style.display === "none" || panel.style.display === "") ? "block" : "none";
    }
    function toggleGamesMenu() {
      const menu = document.getElementById("gamesMenu");
      menu.style.display = (menu.style.display === "none" || menu.style.display === "") ? "block" : "none";
    }
    
    // --- Search Functionality ---
    function openInAboutBlank() {
      let query = document.getElementById("searchInput").value.trim();
      if (!query) return;
      let targetUrl = query;
      if (!/^https?:\/\//i.test(query)) {
        if (query.indexOf(" ") !== -1 || query.indexOf(".") === -1) {
          targetUrl = "https://www.google.com/search?q=" + encodeURIComponent(query);
        } else {
          targetUrl = "https://" + query;
        }
      }
      const proxyBase = document.getElementById("proxySelect").value;
      if (proxyBase) {
        targetUrl = proxyBase + encodeURIComponent(targetUrl);
      }
      const win = window.open("about:blank", "_blank");
      win.document.write(`
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta http-equiv="refresh" content="0;url=${targetUrl}">
          <title>Redirecting...</title>
        </head>
        <body>
          <p>Redirecting, please wait...</p>
        </body>
        </html>
      `);
      win.document.close();
    }
    
    // --- Floating Shapes ---
    let shapeSettings = {
      count: parseInt(document.getElementById("shapeCountSlider").value),
      color: document.getElementById("shapeColorPicker").value,
      type: document.getElementById("shapeTypeSelect").value
    };
    function generateShapes() {
      // Remove any existing shapes.
      document.querySelectorAll('.shape').forEach(elem => elem.remove());
      for (let i = 0; i < shapeSettings.count; i++) {
        const shape = document.createElement('div');
        shape.classList.add('shape');
        const size = Math.floor(Math.random() * 50) + 20;
        shape.style.width = size + "px";
        shape.style.height = size + "px";
        shape.style.left = Math.random() * window.innerWidth + "px";
        shape.style.top = Math.random() * window.innerHeight + "px";
        shape.style.animationDuration = (Math.random() * 20 + 10) + "s";
        shape.style.animationDelay = (Math.random() * 5) + "s";
        shape.style.backgroundColor = shapeSettings.color;
        shape.style.borderRadius = (shapeSettings.type === "circle" ? "50%" : "0%");
        document.body.appendChild(shape);
      }
    }
    function updateShapes() {
      document.querySelectorAll('.shape').forEach(shape => {
        shape.style.backgroundColor = shapeSettings.color;
        shape.style.borderRadius = (shapeSettings.type === "circle" ? "50%" : "0%");
      });
    }
    
    // --- Settings Panel Listeners ---
    document.getElementById("bgColorPicker").addEventListener("input", function() {
      document.body.style.backgroundColor = this.value;
    });
    document.getElementById("bgBrightnessSlider").addEventListener("input", function() {
      document.body.style.filter = "brightness(" + this.value + ")";
    });
    document.getElementById("textboxColorPicker").addEventListener("input", function() {
      document.getElementById("searchInput").style.backgroundColor = this.value;
    });
    document.getElementById("shapeColorPicker").addEventListener("input", function() {
      shapeSettings.color = this.value;
      updateShapes();
    });
    document.getElementById("shapeTypeSelect").addEventListener("change", function() {
      shapeSettings.type = this.value;
      updateShapes();
    });
    document.getElementById("shapeCountSlider").addEventListener("input", function() {
      shapeSettings.count = parseInt(this.value);
      generateShapes();
    });
    
    // --- Game Management ---
    function showMain() {
      document.getElementById("mainContainer").style.display = "block";
      document.getElementById("flappyGame").style.display = "none";
      document.getElementById("snakeGame").style.display = "none";
      document.getElementById("pacmanGame").style.display = "none";
    }
    function exitGame() {
      if (currentGame === "flappy") {
        document.removeEventListener("keydown", flappyKeyHandler);
        clearInterval(gameInterval);
      } else if (currentGame === "snake") {
        document.removeEventListener("keydown", snakeKeyHandler);
        clearInterval(snakeInterval);
      } else if (currentGame === "pacman") {
        document.removeEventListener("keydown", pacmanKeyHandler);
        clearInterval(pacmanInterval);
      }
      currentGame = "";
      showMain();
    }
    
    // --- Flappy Bird Game ---
    let flappyCanvas, flappyCtx;
    let bird, gravity, lift, pipes, pipeGap, pipeWidth, flappyScore, flappyGameOver;
    function startFlappy() {
      toggleGamesMenu();
      document.getElementById("mainContainer").style.display = "none";
      document.getElementById("flappyGame").style.display = "block";
      currentGame = "flappy";
      initFlappy();
    }
    function initFlappy() {
      flappyCanvas = document.getElementById("flappyCanvas");
      flappyCtx = flappyCanvas.getContext("2d");
      bird = { x: 80, y: 150, radius: 10, velocity: 0 };
      gravity = 0.6;
      lift = -10;
      pipes = [];
      pipeGap = 120;
      pipeWidth = 50;
      flappyScore = 0;
      flappyGameOver = false;
      pipes.push({ x: flappyCanvas.width, top: Math.random() * (flappyCanvas.height - pipeGap - 50) + 20 });
      document.addEventListener("keydown", flappyKeyHandler);
      flappyCanvas.addEventListener("mousedown", flappyFlap);
      gameInterval = setInterval(updateFlappy, 20);
    }
    function flappyKeyHandler(e) {
      if (e.code === "Space") {
        flappyFlap();
      }
    }
    function flappyFlap() {
      bird.velocity = lift;
    }
    function updateFlappy() {
      bird.velocity += gravity;
      bird.y += bird.velocity;
      if (bird.y + bird.radius >= flappyCanvas.height || bird.y - bird.radius <= 0) flappyGameOver = true;
      if (pipes.length > 0 && pipes[pipes.length - 1].x < flappyCanvas.width - 200) {
        pipes.push({ x: flappyCanvas.width, top: Math.random() * (flappyCanvas.height - pipeGap - 50) + 20 });
      }
      for (let i = 0; i < pipes.length; i++) {
        pipes[i].x -= 2;
      }
      if (pipes.length > 0 && pipes[0].x + pipeWidth < 0) {
        pipes.shift();
        flappyScore++;
      }
      for (let i = 0; i < pipes.length; i++) {
        let p = pipes[i];
        if (bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + pipeWidth) {
          if (bird.y - bird.radius < p.top || bird.y + bird.radius > p.top + pipeGap) flappyGameOver = true;
        }
      }
      flappyCtx.clearRect(0, 0, flappyCanvas.width, flappyCanvas.height);
      flappyCtx.fillStyle = "yellow";
      flappyCtx.beginPath();
      flappyCtx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
      flappyCtx.fill();
      flappyCtx.fillStyle = "green";
      for (let i = 0; i < pipes.length; i++) {
        let p = pipes[i];
        flappyCtx.fillRect(p.x, 0, pipeWidth, p.top);
        flappyCtx.fillRect(p.x, p.top + pipeGap, pipeWidth, flappyCanvas.height - p.top - pipeGap);
      }
      flappyCtx.fillStyle = "white";
      flappyCtx.font = "20px Arial";
      flappyCtx.fillText("Score: " + flappyScore, 10, 25);
      if (flappyGameOver) {
        clearInterval(gameInterval);
        flappyCtx.fillStyle = "red";
        flappyCtx.font = "40px Arial";
        flappyCtx.fillText("Game Over", flappyCanvas.width / 2 - 100, flappyCanvas.height / 2);
      }
    }
    
    // --- Snake Game ---
    let snakeCanvas, snakeCtx;
    let snake, snakeDirection, snakeFood, snakeSize, snakeGameOver;
    function startSnake() {
      toggleGamesMenu();
      document.getElementById("mainContainer").style.display = "none";
      document.getElementById("snakeGame").style.display = "block";
      currentGame = "snake";
      initSnake();
    }
    function initSnake() {
      snakeCanvas = document.getElementById("snakeCanvas");
      snakeCtx = snakeCanvas.getContext("2d");
      snakeSize = 20;
      snake = [{ x: 200, y: 200 }];
      snakeDirection = "right";
      snakeGameOver = false;
      placeSnakeFood();
      document.addEventListener("keydown", snakeKeyHandler);
      snakeInterval = setInterval(updateSnake, 100);
    }
    function placeSnakeFood() {
      snakeFood = {
        x: Math.floor(Math.random() * (snakeCanvas.width / snakeSize)) * snakeSize,
        y: Math.floor(Math.random() * (snakeCanvas.height / snakeSize)) * snakeSize
      };
    }
    function snakeKeyHandler(e) {
      const key = e.code;
      if (key === "ArrowUp" && snakeDirection !== "down") snakeDirection = "up";
      else if (key === "ArrowDown" && snakeDirection !== "up") snakeDirection = "down";
      else if (key === "ArrowLeft" && snakeDirection !== "right") snakeDirection = "left";
      else if (key === "ArrowRight" && snakeDirection !== "left") snakeDirection = "right";
    }
    function updateSnake() {
      let head = { x: snake[0].x, y: snake[0].y };
      if (snakeDirection === "right") head.x += snakeSize;
      if (snakeDirection === "left") head.x -= snakeSize;
      if (snakeDirection === "up") head.y -= snakeSize;
      if (snakeDirection === "down") head.y += snakeSize;
      if (head.x < 0 || head.x >= snakeCanvas.width || head.y < 0 || head.y >= snakeCanvas.height) snakeGameOver = true;
      for (let i = 0; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) snakeGameOver = true;
      }
      if (snakeGameOver) {
        clearInterval(snakeInterval);
        snakeCtx.fillStyle = "red";
        snakeCtx.font = "30px Arial";
        snakeCtx.fillText("Game Over", snakeCanvas.width / 2 - 70, snakeCanvas.height / 2);
        return;
      }
      snake.unshift(head);
      if (head.x === snakeFood.x && head.y === snakeFood.y) {
        placeSnakeFood();
      } else {
        snake.pop();
      }
      snakeCtx.clearRect(0, 0, snakeCanvas.width, snakeCanvas.height);
      snakeCtx.fillStyle = "lime";
      for (let i = 0; i < snake.length; i++) {
        snakeCtx.fillRect(snake[i].x, snake[i].y, snakeSize, snakeSize);
      }
      snakeCtx.fillStyle = "orange";
      snakeCtx.fillRect(snakeFood.x, snakeFood.y, snakeSize, snakeSize);
    }
    
    // --- Pacman Game ---
    let pacmanCanvas, pacmanCtx;
    let pacman, pacmanDirection, pacmanPellets, pacmanSize;
    function startPacman() {
      toggleGamesMenu();
      document.getElementById("mainContainer").style.display = "none";
      document.getElementById("pacmanGame").style.display = "block";
      currentGame = "pacman";
      initPacman();
    }
    function initPacman() {
      pacmanCanvas = document.getElementById("pacmanCanvas");
      pacmanCtx = pacmanCanvas.getContext("2d");
      pacmanSize = 20;
      pacman = { x: pacmanSize, y: pacmanSize, radius: pacmanSize / 2 };
      pacmanDirection = "right";
      pacmanPellets = [];
      // Fill the canvas with pellets.
      for (let i = 0; i < pacmanCanvas.width; i += pacmanSize) {
        for (let j = 0; j < pacmanCanvas.height; j += pacmanSize) {
          pacmanPellets.push({ x: i, y: j, eaten: false });
        }
      }
      document.addEventListener("keydown", pacmanKeyHandler);
      pacmanInterval = setInterval(updatePacman, 150);
    }
    function pacmanKeyHandler(e) {
      const key = e.code;
      if (key === "ArrowUp") pacmanDirection = "up";
      else if (key === "ArrowDown") pacmanDirection = "down";
      else if (key === "ArrowLeft") pacmanDirection = "left";
      else if (key === "ArrowRight") pacmanDirection = "right";
    }
    function updatePacman() {
      if (pacmanDirection === "right") pacman.x += pacmanSize;
      if (pacmanDirection === "left") pacman.x -= pacmanSize;
      if (pacmanDirection === "up") pacman.y -= pacmanSize;
      if (pacmanDirection === "down") pacman.y += pacmanSize;
      if (pacman.x >= pacmanCanvas.width) pacman.x = 0;
      if (pacman.x < 0) pacman.x = pacmanCanvas.width - pacmanSize;
      if (pacman.y >= pacmanCanvas.height) pacman.y = 0;
      if (pacman.y < 0) pacman.y = pacmanCanvas.height - pacmanSize;
      pacmanPellets.forEach(p => {
        if (!p.eaten && Math.abs(pacman.x - p.x) < pacmanSize && Math.abs(pacman.y - p.y) < pacmanSize) {
          p.eaten = true;
        }
      });
      drawPacman();
    }
    function drawPacman() {
      pacmanCtx.clearRect(0, 0, pacmanCanvas.width, pacmanCanvas.height);
      pacmanCtx.fillStyle = "white";
      pacmanPellets.forEach(p => {
        if (!p.eaten) {
          pacmanCtx.beginPath();
          pacmanCtx.arc(p.x + pacmanSize / 2, p.y + pacmanSize / 2, 3, 0, Math.PI * 2);
          pacmanCtx.fill();
        }
      });
      pacmanCtx.fillStyle = "yellow";
      pacmanCtx.beginPath();
      pacmanCtx.arc(pacman.x + pacmanSize / 2, pacman.y + pacmanSize / 2, pacman.radius, 0.25 * Math.PI, 1.75 * Math.PI);
      pacmanCtx.lineTo(pacman.x + pacmanSize / 2, pacman.y + pacmanSize / 2);
      pacmanCtx.fill();
    }
    
    // Generate floating shapes on load and re-generate on window resize.
    window.onload = function() {
      generateShapes();
    };
    window.onresize = generateShapes;
  </script>
</body>
</html>
